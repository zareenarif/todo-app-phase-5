# Todo AI Chatbot Application Constitution (Phase 4)

<!--
Sync Impact Report:
- Version change: 3.0.0 → 4.0.0
- Major version increment: Fundamental infrastructure transformation from
  direct deployment to containerized Local Kubernetes via Minikube
- Breaking changes:
  - Removed: "Containerization: Not required" constraint
  - Removed: "No Kubernetes or cloud orchestration" from scope exclusions
  - Removed: "Kubernetes orchestration" from explicit out-of-scope list
  - Added: Docker containerization as mandatory (separate images for
    frontend and backend)
  - Added: Helm Charts as single source of truth for deployment
  - Added: Minikube as local Kubernetes target
  - Added: AI DevOps tooling requirement (Gordon, kubectl-ai, kagent)
  - Added: Observability and scalability requirements
  - Added: Pod resilience guarantees
- Modified principles:
  - Principle IV: Simplicity Over Complexity (updated for K8s/Helm context)
  - Principle V: Scope Discipline (reframed for infrastructure scope)
- Added principles:
  - Principle XI: AI-Generated Infrastructure Only
  - Principle XII: Helm as Single Source of Truth
  - Principle XIII: Observable and Resilient Deployment
- Removed sections:
  - "Containerization: Not required" constraint
  - "No Kubernetes or cloud orchestration" constraint
- Added sections:
  - Infrastructure Stack, Deployment Architecture, Helm Chart
    Structure, Observability Requirements, Resilience Guarantees
- Templates requiring updates:
  ⚠ .specify/templates/plan-template.md (pending - constitution check
    gates need K8s/Helm/Docker alignment)
  ⚠ .specify/templates/spec-template.md (pending - needs infrastructure
    deployment sections)
  ⚠ .specify/templates/tasks-template.md (pending - needs K8s/Helm
    task types and infra phases)
- Follow-up TODOs: None
- Impact: Complete infrastructure transformation to containerized
  Kubernetes deployment with AI-generated manifests and Helm charts
-->

## Purpose

This project follows Spec-Driven Development (SDD). The objective of
Phase 4 is to deploy the Phase 3 Todo AI Chatbot on a local Kubernetes
cluster using Minikube, with Helm Charts as the deployment mechanism
and AI DevOps tools (Docker AI Gordon, kubectl-ai, kagent) driving all
infrastructure generation.

All development decisions MUST be guided by this constitution and the
approved specification. No implementation may begin until the
specification, plan, and tasks are agreed upon.

**Phase Transition:** Phase 4 builds upon the Phase 3 AI Chatbot by
containerizing the frontend and backend separately, packaging them as
Helm charts, and deploying to a local Minikube Kubernetes cluster. The
application logic from Phase 3 is preserved; Phase 4 focuses
exclusively on infrastructure, containerization, and orchestration.

**AI DevOps Context:** This phase enforces zero manual infrastructure
coding. All Dockerfiles, Helm charts, Kubernetes manifests, and
deployment configurations MUST be generated by AI tools (Claude Code,
Docker AI Gordon, kubectl-ai, kagent). Human involvement is limited to
specification, review, and approval.

## Core Principles

### I. Specification Before Implementation

All features MUST be specified before any code is written. The
specification defines what will be built, why it is needed, and what
success looks like.

**Non-negotiable rules:**
- No coding without an approved specification
- Specifications MUST be concrete and testable
- Requirements MUST be clear and unambiguous
- Infrastructure configurations MUST be explicitly defined
- Deployment behavior MUST include acceptance criteria

**Rationale:** Specifications prevent scope creep, ensure alignment,
and provide a shared understanding. For Kubernetes deployments,
specifications serve as contracts between containers, services,
and the cluster.

### II. Planning Before Coding

All implementations MUST have an architectural plan approved before
code is generated. The plan defines how the specification will be
achieved technically across the deployment stack.

**Non-negotiable rules:**
- No coding without an approved implementation plan
- Plans MUST identify all components (frontend container, backend
  container, Helm charts, Kubernetes services) and their interactions
- Plans MUST define container image specifications, resource limits,
  and service exposure strategies
- Plans MUST address health checks and readiness probes
- Plans MUST specify the Helm values hierarchy

**Rationale:** Planning ensures technical decisions are deliberate
and documented. It prevents reactive configuration and validates that
Docker builds, Helm charts, and Kubernetes resources align.

### III. Tasks Before Execution

All work MUST be broken down into discrete, testable tasks before
execution begins.

**Non-negotiable rules:**
- No execution without a defined task list
- Each task MUST be independently verifiable
- Tasks MUST reference specific files, manifests, and charts
- Tasks MUST specify layer: Dockerfile, Helm chart, Kubernetes
  manifest, or cluster configuration
- Tasks MUST identify dependencies

**Rationale:** Task decomposition ensures work is trackable, testable,
and completable in small increments across infrastructure layers.

### IV. Simplicity Over Complexity

The implementation MUST be as simple as possible while meeting all
requirements. Complexity requires explicit justification.

**Non-negotiable rules:**
- Use established tools and patterns (Docker, Helm, Minikube,
  kubectl)
- No custom orchestration frameworks (use Helm and kubectl)
- No unnecessary abstraction layers in infrastructure
- Clear, readable manifests over clever templating
- Leverage Helm defaults unless requirements demand customization
- Kubernetes resources MUST use standard API objects (Deployment,
  Service, ConfigMap, Secret)

**Rationale:** Simplicity reduces misconfiguration and improves
debuggability. Standard Kubernetes patterns ensure portability and
team comprehension.

### V. Scope Discipline

This project maintains strict scope discipline. Only infrastructure
and deployment features explicitly defined in the Phase 4
specification may be implemented.

**Non-negotiable rules:**
- ALL features MUST follow SDD workflow: specification -> plan ->
  tasks -> implementation
- No features may be added without user-approved specification
- Follow deployment requirements EXACTLY — no feature creep
- No application logic changes unless explicitly required for
  containerization
- Explicitly out of scope:
  - Cloud provider deployments (AWS, GCP, Azure)
  - CI/CD pipeline configuration
  - Ingress controllers beyond basic Minikube access
  - Service mesh (Istio, Linkerd)
  - Custom operators or CRDs
  - Production TLS/certificate management
  - Multi-cluster deployments
  - Persistent volume provisioners beyond Minikube defaults

**Rationale:** Scope discipline ensures focus on local Kubernetes
deployment. Every unspecified infrastructure addition adds complexity
and potential failure points.

### VI. Security by Design

Security MUST be built into every layer of the deployment.

**Non-negotiable rules:**
- Secrets MUST be stored in Kubernetes Secrets, never in manifests
  or Helm values committed to version control
- Container images MUST use non-root users where possible
- Container images MUST use specific base image tags (no `latest`)
- Environment variables MUST be injected via ConfigMaps or Secrets
- CORS policies MUST be explicitly configured
- Network policies SHOULD restrict inter-pod communication to
  necessary paths

**Rationale:** Security vulnerabilities in infrastructure compromise
the entire deployment. Container and Kubernetes security is
foundational.

### VII. Stateless Server & MCP Tools

The backend server and all MCP tools MUST remain stateless. This
constraint from Phase 3 is preserved and reinforced by Kubernetes
deployment patterns.

**Non-negotiable rules:**
- The FastAPI server MUST be stateless (enabling horizontal scaling)
- MCP tools MUST be stateless — no in-memory caching of user data
- Pod restarts MUST NOT cause data loss
- All state MUST be persisted in the database (external to cluster)
- Kubernetes Deployments (not StatefulSets) MUST be used for
  application pods

**Rationale:** Statelessness enables Kubernetes to freely reschedule,
restart, and scale pods without data loss or session affinity
requirements.

### VIII. MCP Tool Discipline

MCP tools MUST remain the exclusive interface between the AI agent
and task data. This constraint from Phase 3 is preserved unchanged.

**Non-negotiable rules:**
- AI agent MUST use MCP tools for ALL task actions
- No direct database access by the AI agent
- MCP tools MUST ONLY expose task operations
- Each MCP tool MUST have a clear, single responsibility
- Tool input/output schemas MUST be explicitly defined

**Rationale:** MCP compliance is preserved from Phase 3. The
containerization layer MUST NOT alter the application's architectural
boundaries.

### IX. Conversation State Persistence

Conversation state MUST be persisted in the database. This constraint
from Phase 3 is preserved unchanged.

**Non-negotiable rules:**
- All conversation history MUST be stored in the database
- Conversation context MUST survive pod restarts
- Each conversation MUST be associated with an authenticated user
- No in-memory conversation buffers or caches

**Rationale:** Kubernetes pod restarts are expected behavior.
Database-backed persistence ensures conversation continuity.

### X. AI Agent Boundary Discipline

The AI agent MUST operate within strict boundaries. This constraint
from Phase 3 is preserved unchanged.

**Non-negotiable rules:**
- The AI agent MUST use OpenAI Agents SDK
- The agent MUST NOT contain business logic
- The agent MUST map natural language to appropriate MCP tool calls
- The agent MUST NOT access the database directly

**Rationale:** Clean agent boundaries are preserved from Phase 3.
Containerization MUST NOT blur architectural responsibilities.

### XI. AI-Generated Infrastructure Only

All infrastructure artifacts MUST be generated by AI tools. No
manual coding of Dockerfiles, Helm charts, or Kubernetes manifests
by humans is permitted.

**Non-negotiable rules:**
- ALL Dockerfiles MUST be generated by AI (Claude Code or Docker
  AI Gordon)
- ALL Helm charts MUST be generated by AI (Claude Code or
  kubectl-ai)
- ALL Kubernetes manifests MUST be generated by AI tools
- Human role is LIMITED to: specification, review, approval, and
  execution of AI-generated commands
- AI DevOps tools (Gordon, kubectl-ai, kagent) MUST be used where
  they provide capability
- Claude Code is the primary code generation agent for all
  infrastructure artifacts

**Rationale:** Phase 4 validates AI-driven DevOps workflows. Human
manual infrastructure coding defeats the purpose of the agentic
dev stack. AI generation ensures reproducibility and consistency.

### XII. Helm as Single Source of Truth

Helm MUST be the single authoritative source for all Kubernetes
deployment configurations. No raw kubectl apply of standalone
manifests is permitted for application resources.

**Non-negotiable rules:**
- ALL application Kubernetes resources MUST be defined in Helm
  charts
- Helm values.yaml MUST be the single configuration surface
- Environment-specific overrides MUST use Helm values files
- No standalone YAML manifests for application resources (all MUST
  be Helm templates)
- Helm releases MUST be used for install, upgrade, and rollback
- Chart versioning MUST follow semantic versioning

**Rationale:** Helm provides declarative, versioned, reproducible
deployments. A single source of truth prevents configuration drift
and ensures all cluster state is trackable and reversible.

### XIII. Observable and Resilient Deployment

All deployed resources MUST be observable and MUST survive expected
failure scenarios.

**Non-negotiable rules:**
- ALL pods MUST define health checks (liveness and readiness probes)
- ALL pods MUST reach Running state for deployment to be considered
  successful
- ALL services MUST be accessible via Minikube (NodePort or
  minikube service)
- System MUST survive pod restarts without data loss
- Resource requests and limits MUST be defined for all containers
- Pod logs MUST be accessible via kubectl logs
- Deployment rollout status MUST be verifiable via kubectl

**Rationale:** Observability and resilience are fundamental to
Kubernetes operations. Without health checks and resource governance,
deployments are fragile and undebuggable.

## Technology Stack

The following technologies are REQUIRED and MUST be used exactly
as specified:

### Application (Preserved from Phase 3)
- **Frontend:** OpenAI ChatKit (conversational interface)
- **Backend:** Python FastAPI with SQLModel ORM
- **AI Logic:** OpenAI Agents SDK
- **MCP Server:** Official MCP SDK
- **Database:** Neon Serverless PostgreSQL (external to cluster)
- **Authentication:** Better Auth

### Infrastructure (Phase 4 — NEW)
- **Container Runtime:** Docker Desktop
- **Container AI:** Docker AI Agent (Gordon) for Dockerfile
  generation and optimization
- **Kubernetes Distribution:** Minikube (local cluster)
- **Package Manager:** Helm 3 (chart-based deployment)
- **Cluster CLI:** kubectl + kubectl-ai (AI-assisted kubectl)
- **Agent Orchestration:** kagent (AI agent for Kubernetes
  operations)
- **Registry:** Local Docker images (minikube image load or
  minikube docker-env)

### Development & Tooling
- **Spec-Driven Development:** Claude Code + SpecKit Plus
- **Code Generation:** Claude Code (ALL code and infrastructure
  MUST be AI-generated, NO manual coding by humans)
- **Version Control:** Git with semantic commit messages
- **Environment Variables:** Kubernetes Secrets and ConfigMaps
  (never committed to version control)

**Rationale:** This stack enables fully AI-driven local Kubernetes
deployment. Docker AI (Gordon) generates optimized Dockerfiles,
kubectl-ai assists with cluster operations, kagent provides
AI-powered Kubernetes management, and Helm ensures reproducible
deployments.

## Technical Constraints

### Container Architecture
- **Separate Images:** Frontend and backend MUST be containerized
  as separate Docker images
- **Multi-stage Builds:** Dockerfiles SHOULD use multi-stage builds
  to minimize image size
- **Non-root:** Containers SHOULD run as non-root users
- **Pinned Base Images:** Base images MUST use specific version tags

### Kubernetes Architecture
- **Namespace:** Application MUST deploy to a dedicated namespace
- **Deployments:** Application pods MUST use Deployment resources
  (not StatefulSets or DaemonSets)
- **Services:** Each Deployment MUST have a corresponding Service
- **ConfigMaps:** Non-sensitive configuration MUST use ConfigMaps
- **Secrets:** Sensitive values (API keys, database URLs) MUST use
  Kubernetes Secrets
- **Resource Limits:** All containers MUST define CPU and memory
  requests and limits
- **Health Checks:** All containers MUST define liveness and
  readiness probes

### Helm Chart Structure
- **Chart per Application:** One Helm chart for the entire todo
  application (with subcharts or templates for frontend/backend)
- **Values Hierarchy:** Default values in values.yaml, overrides
  via --set or -f flags
- **Template Helpers:** Common labels, selectors, and names in
  _helpers.tpl
- **NOTES.txt:** Post-install instructions for accessing the
  application

### Database Constraints (Preserved from Phase 3)
- **External Database:** Neon PostgreSQL runs OUTSIDE the cluster
- **Connection String:** Injected via Kubernetes Secret
- **ORM Required:** All database access MUST use SQLModel
- **User Isolation:** Every user-data table MUST have `user_id`

### Deployment Constraints
- **Local Only:** Minikube is the ONLY deployment target
- **No Cloud:** No AWS, GCP, or Azure resources
- **No CI/CD:** No automated pipeline configuration
- **No Service Mesh:** No Istio or Linkerd
- **No Ingress Controller:** Use NodePort or minikube service for
  access

## Deployment Architecture

### Container Layout
```
┌─────────────────────────────────────────────┐
│              Minikube Cluster                │
│                                             │
│  ┌──────────────┐    ┌──────────────────┐   │
│  │   Frontend    │    │    Backend        │   │
│  │   Deployment  │    │    Deployment     │   │
│  │  (Next.js)    │    │   (FastAPI +      │   │
│  │              │    │    MCP + Agent)    │   │
│  └──────┬───────┘    └────────┬──────────┘   │
│         │                     │              │
│  ┌──────┴───────┐    ┌───────┴──────────┐   │
│  │   Frontend    │    │    Backend        │   │
│  │   Service     │    │    Service        │   │
│  │  (NodePort)   │    │   (ClusterIP/     │   │
│  │              │    │    NodePort)       │   │
│  └──────────────┘    └──────────────────┘   │
│                                             │
│  ┌──────────────┐    ┌──────────────────┐   │
│  │  ConfigMap    │    │   Secret          │   │
│  │  (app config) │    │  (API keys, DB)   │   │
│  └──────────────┘    └──────────────────┘   │
└─────────────────────────────────────────────┘
                         │
                         ▼
              ┌──────────────────┐
              │  Neon PostgreSQL   │
              │  (External DB)     │
              └──────────────────┘
```

### Access Pattern
1. User accesses frontend via `minikube service frontend`
2. Frontend communicates with backend via Kubernetes Service DNS
3. Backend connects to external Neon PostgreSQL via Secret

## Helm Chart Structure

```
helm/todo-chatbot/
├── Chart.yaml              # Chart metadata and version
├── values.yaml             # Default configuration values
├── templates/
│   ├── _helpers.tpl        # Template helper functions
│   ├── NOTES.txt           # Post-install access instructions
│   ├── frontend-deployment.yaml
│   ├── frontend-service.yaml
│   ├── backend-deployment.yaml
│   ├── backend-service.yaml
│   ├── configmap.yaml
│   └── secret.yaml
└── .helmignore
```

## Observability Requirements

- **Pod Logs:** All application logs MUST be written to stdout/stderr
  for kubectl logs access
- **Health Endpoints:** Backend MUST expose /health for liveness
  and /ready for readiness probes
- **Deployment Status:** `kubectl rollout status` MUST report
  successful deployment
- **Resource Monitoring:** `kubectl top pods` MUST show resource
  usage within defined limits

## Resilience Guarantees

- **Pod Restart Survival:** Application MUST function correctly
  after pod restart (kubectl delete pod)
- **Rolling Updates:** Helm upgrade MUST perform rolling updates
  with zero downtime
- **Rollback:** `helm rollback` MUST restore previous working state
- **Stateless Validation:** Killing and recreating pods MUST NOT
  cause data loss (all state in external database)

## Environment Variables (REQUIRED)

Injected via Kubernetes Secrets and ConfigMaps:

**Secrets:**
- `DATABASE_URL` — Neon PostgreSQL connection string
- `BETTER_AUTH_SECRET` — Shared secret for authentication
- `OPENAI_API_KEY` — OpenAI API key for Agents SDK

**ConfigMaps:**
- `CORS_ORIGINS` — Allowed frontend origins
- `BACKEND_URL` — Internal backend service URL for frontend
- `PORT` — Application port (backend: 8000, frontend: 3000)

## Quality Standards

**Infrastructure:**
- Helm charts MUST pass `helm lint` without errors
- Dockerfiles MUST build without warnings
- All Kubernetes resources MUST pass `kubectl apply --dry-run`
- Resource names MUST follow Kubernetes naming conventions
- Labels MUST include app, component, and version

**Application (Preserved from Phase 3):**
- Type hints on all functions
- Pydantic models for all request/response schemas
- Proper error handling with appropriate status codes
- All endpoints include API documentation (OpenAPI/Swagger)

**General:**
- Clean and readable configuration (self-documenting)
- No hardcoded secrets or environment-specific values
- No dead code or unused resources

## Testing Requirements

**Deployment Verification (REQUIRED):**
- Minikube cluster starts successfully
- Docker images build without errors
- Helm install completes without errors
- All pods reach Running state
- All services have valid endpoints
- Frontend is accessible via minikube service
- Backend API responds to health check
- End-to-end user flow works through Kubernetes services
- Pod restart does not cause data loss
- Helm upgrade performs rolling update
- Helm rollback restores previous state

## Governance

This constitution supersedes all other development practices. Any
amendments MUST be documented with rationale and approved before
taking effect.

**Compliance:**
- All specifications, plans, and tasks MUST be verified against
  this constitution
- Any complexity introduced MUST be justified explicitly
- ALL code and infrastructure generation MUST be performed by AI
  tools (no manual coding by humans)
- Helm chart compliance MUST be verified at every stage
- Kubernetes resource compliance MUST be validated with dry-run

**Amendment Process:**
- Amendments require explicit documentation of change and rationale
- Version MUST be incremented per semantic versioning:
  - MAJOR: Breaking changes to architecture, stack, or principles
  - MINOR: New principles, requirements, or substantial additions
  - PATCH: Clarifications, typo fixes, non-breaking refinements
- All dependent templates and docs MUST be updated
- All active features MUST be reviewed for compliance after
  amendments

**Version:** 4.0.0 | **Ratified:** 2026-01-05 | **Last Amended:** 2026-02-09

## Amendment History

### Version 4.0.0 (2026-02-09)

**Amendment:** Complete infrastructure transformation to containerized
Local Kubernetes deployment via Minikube with AI-generated artifacts

**Rationale:** Phase 4 deploys the Phase 3 AI Chatbot to a local
Kubernetes cluster. The application logic is preserved unchanged;
this phase focuses on containerization (Docker), orchestration
(Kubernetes/Minikube), packaging (Helm), and AI-driven DevOps
tooling (Gordon, kubectl-ai, kagent).

**Major Changes:**
- **Infrastructure:** Added Docker containerization, Minikube,
  Helm Charts
- **AI DevOps:** Added Docker AI Gordon, kubectl-ai, kagent as
  required tools
- **Principles:** Added AI-Generated Infrastructure Only (XI),
  Helm as Single Source of Truth (XII), Observable and Resilient
  Deployment (XIII)
- **Scope:** Kubernetes orchestration moved from out-of-scope to
  primary scope (local only)
- **Deployment:** Defined container layout, Helm chart structure,
  access patterns
- **Observability:** Added health checks, logging, and monitoring
  requirements
- **Resilience:** Added pod restart survival and rolling update
  guarantees

**Breaking Changes from Phase 3:**
- Containerization now required (was "Not required")
- Kubernetes orchestration now primary scope (was out of scope)
- Secrets management moved to Kubernetes Secrets (was .env files)
- Deployment target is Minikube cluster (was direct process)

**Preserved from Phase 3:**
- All application logic (FastAPI, MCP, OpenAI Agents SDK)
- ChatKit frontend
- SQLModel ORM + Neon PostgreSQL
- Better Auth authentication
- MCP tool architecture
- Conversation state persistence
- AI agent boundary discipline
- All data models unchanged
- Core SDD principles (I, II, III)

### Version 3.0.0 (2026-02-08)

**Amendment:** Complete architectural transformation to AI-powered
conversational chatbot with MCP architecture

**Rationale:** Phase 3 evolved the full-stack web application into
an AI-powered conversational todo chatbot with MCP-compliant
stateless tool architecture.

### Version 2.0.0 (2026-01-05)

**Amendment:** Complete architectural transformation to full-stack
web application

### Version 1.2.0 (2026-01-04)

**Amendment:** Extended Task Entity Rules for advanced task management

### Version 1.1.0 (2026-01-03)

**Amendment:** Updated Principle V from "No Features Beyond Phase I
Scope" to "Scope Discipline and Controlled Enhancement"
