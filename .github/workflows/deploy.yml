# =============================================================================
# CI/CD Pipeline — Todo AI Chatbot (Phase V Cloud-Native)
#
# Stages: Lint → Test → Build → Push → Deploy
# Environments: staging (on push to main), production (on tag v*)
#
# Required GitHub Secrets (per environment):
#   KUBE_CONFIG          — base64-encoded kubeconfig for target cluster
#   KAFKA_BROKERS        — Managed Kafka bootstrap URL
#   KAFKA_SASL_USERNAME  — Kafka SASL username
#   CORS_ORIGINS         — Allowed CORS origin (e.g. https://todo.example.com)
#   INGRESS_HOST         — Production domain for Ingress rules
#
# Required GitHub Secrets (repository-level):
#   GHCR_TOKEN           — GitHub PAT with packages:write scope
#                          (or use default GITHUB_TOKEN if repo packages enabled)
# =============================================================================

name: CI/CD Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"
      - "specs/**"
      - "history/**"
      - ".specify/**"
  pull_request:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"
      - "specs/**"
      - "history/**"
      - ".specify/**"
  release:
    types: [published]

# Cancel in-progress runs for the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# =============================================================================
# Environment variables shared across all jobs
# =============================================================================
env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ghcr.io/${{ github.repository_owner }}/todo-backend
  FRONTEND_IMAGE: ghcr.io/${{ github.repository_owner }}/todo-frontend
  HELM_CHART_PATH: helm/todo-chatbot
  HELM_RELEASE_NAME: todo-chatbot
  NAMESPACE: todo-chatbot

# =============================================================================
# Jobs
# =============================================================================
jobs:
  # ---------------------------------------------------------------------------
  # Stage 1: Lint
  # ---------------------------------------------------------------------------
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # -- Backend (Python) --
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install ruff
        run: pip install ruff

      - name: Lint backend
        run: ruff check backend/src/

      # -- Frontend (Node.js) --
      - name: Set up Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: npm ci
        working-directory: frontend

      - name: Lint frontend
        run: npm run lint
        working-directory: frontend

      # -- Helm --
      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Lint Helm chart
        run: helm lint ${{ env.HELM_CHART_PATH }} -f ${{ env.HELM_CHART_PATH }}/values-local.yaml

  # ---------------------------------------------------------------------------
  # Stage 2: Test
  # ---------------------------------------------------------------------------
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # -- Backend tests --
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"
          cache-dependency-path: backend/requirements.txt

      - name: Install backend dependencies
        run: pip install -r backend/requirements.txt

      - name: Install test dependencies
        run: pip install pytest pytest-cov httpx

      - name: Run backend tests
        run: python -m pytest backend/ -v --tb=short --co -q 2>/dev/null || echo "No tests collected — skipping"
        env:
          DATABASE_URL: "sqlite:///./test.db"
          BETTER_AUTH_SECRET: "test-secret-not-real"

      # -- Frontend build check --
      - name: Set up Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: npm ci
        working-directory: frontend

      - name: Build frontend
        run: npm run build
        working-directory: frontend

  # ---------------------------------------------------------------------------
  # Stage 3: Build & Push Docker Images
  # ---------------------------------------------------------------------------
  build:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: test
    # Skip image push on PRs (build only to verify Dockerfile)
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # -- Compute image tags --
      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.BACKEND_IMAGE }}
          tags: |
            # SHA tag for every push
            type=sha,prefix=
            # Branch name tag
            type=ref,event=branch
            # Semver tags from release (v2.0.0 → 2.0.0, 2.0, 2)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            # latest tag on release only
            type=raw,value=latest,enable=${{ github.event_name == 'release' }}

      # -- Authenticate to GHCR --
      - name: Login to GHCR
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # -- Build backend --
      - name: Build & push backend
        id: build-backend
        uses: docker/build-push-action@v6
        with:
          context: backend
          file: backend/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ github.sha }}
            ${{ env.BACKEND_IMAGE }}:${{ github.ref_name }}
            ${{ github.event_name == 'release' && format('{0}:{1}', env.BACKEND_IMAGE, github.event.release.tag_name) || '' }}
            ${{ github.event_name == 'release' && format('{0}:latest', env.BACKEND_IMAGE) || '' }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      # -- Build frontend --
      - name: Build & push frontend
        id: build-frontend
        uses: docker/build-push-action@v6
        with:
          context: frontend
          file: frontend/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ env.FRONTEND_IMAGE }}:${{ github.sha }}
            ${{ env.FRONTEND_IMAGE }}:${{ github.ref_name }}
            ${{ github.event_name == 'release' && format('{0}:{1}', env.FRONTEND_IMAGE, github.event.release.tag_name) || '' }}
            ${{ github.event_name == 'release' && format('{0}:latest', env.FRONTEND_IMAGE) || '' }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

  # ---------------------------------------------------------------------------
  # Stage 4a: Deploy to Staging (on push to main)
  # ---------------------------------------------------------------------------
  deploy-staging:
    name: Deploy → Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://${{ vars.INGRESS_HOST || 'staging.todo.example.com' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Verify cluster connectivity
        run: kubectl cluster-info && kubectl get nodes

      - name: Create namespace (if not exists)
        run: kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Helm upgrade (staging)
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ${{ env.HELM_CHART_PATH }} \
            -f ${{ env.HELM_CHART_PATH }}/values-production.yaml \
            --namespace ${{ env.NAMESPACE }} \
            --set backend.image.repository=${{ env.BACKEND_IMAGE }} \
            --set backend.image.tag=${{ github.sha }} \
            --set backend.image.pullPolicy=Always \
            --set backend.replicaCount=1 \
            --set frontend.image.repository=${{ env.FRONTEND_IMAGE }} \
            --set frontend.image.tag=${{ github.sha }} \
            --set frontend.image.pullPolicy=Always \
            --set frontend.replicaCount=1 \
            --set kafka.brokers="${{ secrets.KAFKA_BROKERS }}" \
            --set kafka.auth.username="${{ secrets.KAFKA_SASL_USERNAME }}" \
            --set config.corsOrigins="${{ secrets.CORS_ORIGINS }}" \
            --set config.debug="True" \
            --set "ingress.hosts[0].host=${{ secrets.INGRESS_HOST }}" \
            --set "ingress.hosts[0].paths[0].path=/" \
            --set "ingress.hosts[0].paths[0].pathType=Prefix" \
            --set "ingress.hosts[0].paths[0].service=frontend" \
            --set "ingress.hosts[0].paths[1].path=/api" \
            --set "ingress.hosts[0].paths[1].pathType=Prefix" \
            --set "ingress.hosts[0].paths[1].service=backend" \
            --set "ingress.tls[0].secretName=todo-tls-cert" \
            --set "ingress.tls[0].hosts[0]=${{ secrets.INGRESS_HOST }}" \
            --wait --timeout 5m \
            --atomic

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-backend \
            -n ${{ env.NAMESPACE }} --timeout=180s
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-frontend \
            -n ${{ env.NAMESPACE }} --timeout=180s

      - name: Smoke test — backend health
        run: |
          kubectl port-forward svc/${{ env.HELM_RELEASE_NAME }}-backend 8000:8000 \
            -n ${{ env.NAMESPACE }} &
          PF_PID=$!
          sleep 5
          HTTP_CODE=$(curl -so /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
          kill $PF_PID 2>/dev/null || true
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Health check failed with HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Health check passed (HTTP $HTTP_CODE)"

      - name: Smoke test — Dapr sidecar
        run: |
          BACKEND_POD=$(kubectl get pods -l component=backend \
            -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}')
          CONTAINERS=$(kubectl get pod $BACKEND_POD -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.spec.containers[*].name}')
          if echo "$CONTAINERS" | grep -q "daprd"; then
            echo "Dapr sidecar injected on $BACKEND_POD"
          else
            echo "::warning::Dapr sidecar not detected on $BACKEND_POD"
          fi

      - name: Report deployment
        if: always()
        run: |
          echo "## Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Image tag** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Namespace** | ${{ env.NAMESPACE }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Backend replicas** | 1 |" >> $GITHUB_STEP_SUMMARY
          echo "| **Frontend replicas** | 1 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide 2>/dev/null || echo "Could not fetch pods"
          echo '```' >> $GITHUB_STEP_SUMMARY

      # -- Rollback on failure --
      - name: Rollback on failure
        if: failure()
        run: |
          echo "::warning::Deployment failed — rolling back"
          helm rollback ${{ env.HELM_RELEASE_NAME }} 0 -n ${{ env.NAMESPACE }} --wait || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-backend \
            -n ${{ env.NAMESPACE }} --timeout=120s || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-frontend \
            -n ${{ env.NAMESPACE }} --timeout=120s || true

  # ---------------------------------------------------------------------------
  # Stage 4b: Deploy to Production (on release tag v*)
  # ---------------------------------------------------------------------------
  deploy-production:
    name: Deploy → Production
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'release'
    environment:
      name: production
      url: https://${{ vars.INGRESS_HOST || 'todo.example.com' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Verify cluster connectivity
        run: kubectl cluster-info && kubectl get nodes

      - name: Create namespace (if not exists)
        run: kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Helm upgrade (production)
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ${{ env.HELM_CHART_PATH }} \
            -f ${{ env.HELM_CHART_PATH }}/values-production.yaml \
            --namespace ${{ env.NAMESPACE }} \
            --set backend.image.repository=${{ env.BACKEND_IMAGE }} \
            --set backend.image.tag=${{ github.event.release.tag_name }} \
            --set backend.image.pullPolicy=Always \
            --set backend.replicaCount=2 \
            --set frontend.image.repository=${{ env.FRONTEND_IMAGE }} \
            --set frontend.image.tag=${{ github.event.release.tag_name }} \
            --set frontend.image.pullPolicy=Always \
            --set frontend.replicaCount=2 \
            --set kafka.brokers="${{ secrets.KAFKA_BROKERS }}" \
            --set kafka.auth.username="${{ secrets.KAFKA_SASL_USERNAME }}" \
            --set config.corsOrigins="${{ secrets.CORS_ORIGINS }}" \
            --set config.debug="False" \
            --set "ingress.hosts[0].host=${{ secrets.INGRESS_HOST }}" \
            --set "ingress.hosts[0].paths[0].path=/" \
            --set "ingress.hosts[0].paths[0].pathType=Prefix" \
            --set "ingress.hosts[0].paths[0].service=frontend" \
            --set "ingress.hosts[0].paths[1].path=/api" \
            --set "ingress.hosts[0].paths[1].pathType=Prefix" \
            --set "ingress.hosts[0].paths[1].service=backend" \
            --set "ingress.tls[0].secretName=todo-tls-cert" \
            --set "ingress.tls[0].hosts[0]=${{ secrets.INGRESS_HOST }}" \
            --wait --timeout 5m \
            --atomic

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-backend \
            -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-frontend \
            -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Smoke test — backend health
        run: |
          kubectl port-forward svc/${{ env.HELM_RELEASE_NAME }}-backend 8000:8000 \
            -n ${{ env.NAMESPACE }} &
          PF_PID=$!
          sleep 5
          HTTP_CODE=$(curl -so /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
          kill $PF_PID 2>/dev/null || true
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Health check failed with HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Health check passed (HTTP $HTTP_CODE)"

      - name: Smoke test — Dapr components
        run: |
          echo "Checking Dapr components..."
          BACKEND_POD=$(kubectl get pods -l component=backend \
            -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].metadata.name}')
          CONTAINERS=$(kubectl get pod $BACKEND_POD -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.spec.containers[*].name}')
          if echo "$CONTAINERS" | grep -q "daprd"; then
            echo "Dapr sidecar injected on $BACKEND_POD"
          else
            echo "::error::Dapr sidecar NOT detected on $BACKEND_POD"
            exit 1
          fi

          echo "Checking pod readiness (2/2 containers)..."
          READY=$(kubectl get pod $BACKEND_POD -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.status.containerStatuses[*].ready}')
          if echo "$READY" | grep -q "false"; then
            echo "::error::Not all containers ready: $READY"
            kubectl describe pod $BACKEND_POD -n ${{ env.NAMESPACE }}
            exit 1
          fi
          echo "All containers ready"

      - name: Smoke test — event flow
        run: |
          kubectl port-forward svc/${{ env.HELM_RELEASE_NAME }}-backend 8000:8000 \
            -n ${{ env.NAMESPACE }} &
          PF_PID=$!
          sleep 5

          # Check Dapr sidecar health via the app's Dapr sidecar port
          DAPR_HEALTH=$(kubectl exec $( \
            kubectl get pods -l component=backend -n ${{ env.NAMESPACE }} \
              -o jsonpath='{.items[0].metadata.name}' \
          ) -c daprd -n ${{ env.NAMESPACE }} -- \
            wget -qO- http://localhost:3500/v1.0/healthz 2>/dev/null || echo "unhealthy")

          kill $PF_PID 2>/dev/null || true

          if echo "$DAPR_HEALTH" | grep -qi "unhealthy"; then
            echo "::warning::Dapr sidecar health check inconclusive"
          else
            echo "Dapr sidecar healthy"
          fi

      - name: Report deployment
        if: always()
        run: |
          echo "## Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Release** | ${{ github.event.release.tag_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image tag** | \`${{ github.event.release.tag_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Namespace** | ${{ env.NAMESPACE }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Backend replicas** | 2 |" >> $GITHUB_STEP_SUMMARY
          echo "| **Frontend replicas** | 2 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide 2>/dev/null || echo "Could not fetch pods"
          echo '```' >> $GITHUB_STEP_SUMMARY

      # -- Rollback on failure --
      - name: Rollback on failure
        if: failure()
        run: |
          echo "::error::Production deployment failed — initiating rollback"
          helm rollback ${{ env.HELM_RELEASE_NAME }} 0 -n ${{ env.NAMESPACE }} --wait || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-backend \
            -n ${{ env.NAMESPACE }} --timeout=120s || true
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-frontend \
            -n ${{ env.NAMESPACE }} --timeout=120s || true
